'use strict';

var _path = require('./path');

var mockCatalogConfig = {
  basePath: '/',
  useBrowserHistory: true,
  pagePaths: new Set(['/', '/foo/bar']),
  page: {
    path: '/foo/bar'
  }
};

test('Parse path', function () {
  expect((0, _path.parsePath)('/foo/bar', mockCatalogConfig)).toEqual({ pathname: '/foo/bar', hash: '' });
});

test('Parse path with trailing slash', function () {
  expect((0, _path.parsePath)('/foo/bar/', mockCatalogConfig)).toEqual({ pathname: '/foo/bar', hash: '' });
});

test('Parse path with hash', function () {
  expect((0, _path.parsePath)('/foo/bar#baz', mockCatalogConfig)).toEqual({ pathname: '/foo/bar', hash: '#baz' });
});

test('Parse path with only hash (pathname is current page)', function () {
  expect((0, _path.parsePath)('#baz', mockCatalogConfig)).toEqual({ pathname: '/foo/bar', hash: '#baz' });
});

test('Leave index path alone', function () {
  expect((0, _path.parsePath)('/', mockCatalogConfig)).toEqual({ pathname: '/', hash: '' });
});

var mockCatalogConfigWithHashHistory = {
  basePath: '',
  useBrowserHistory: false,
  pagePaths: new Set(['/', '/foo/bar']),
  page: {
    path: '/foo/bar'
  }
};

test('Hash history: Parse path', function () {
  expect((0, _path.parsePath)('/foo/bar', mockCatalogConfigWithHashHistory)).toEqual({ pathname: '/foo/bar', query: {} });
});

test('Hash history: Parse path with trailing slash', function () {
  expect((0, _path.parsePath)('/foo/bar/', mockCatalogConfigWithHashHistory)).toEqual({ pathname: '/foo/bar', query: {} });
});

test('Hash history: Parse path with hash', function () {
  expect((0, _path.parsePath)('/foo/bar#baz', mockCatalogConfigWithHashHistory)).toEqual({ pathname: '/foo/bar', query: { a: 'baz' } });
});

test('Hash history: Parse path with only hash (pathname is current page)', function () {
  expect((0, _path.parsePath)('#baz', mockCatalogConfigWithHashHistory)).toEqual({ pathname: '/foo/bar', query: { a: 'baz' } });
});

// Internal paths

test('Internal path', function () {
  expect((0, _path.isInternalPath)('/foo/bar', mockCatalogConfig)).toBe(true);
});

test('Internal path with trailing slash', function () {
  expect((0, _path.isInternalPath)('/foo/bar/', mockCatalogConfig)).toBe(true);
});

test('Parse path with no leading slash', function () {
  expect((0, _path.parsePath)('foo/bar', mockCatalogConfig)).toEqual({ pathname: '/foo/bar', hash: '' });
});

test('Internal path with hash', function () {
  expect((0, _path.isInternalPath)('/foo/bar#baz', mockCatalogConfig)).toBe(true);
});

test('Internal path with trailing slash and hash', function () {
  expect((0, _path.isInternalPath)('/foo/bar/#baz', mockCatalogConfig)).toBe(true);
});

test('Internal path with only hash', function () {
  expect((0, _path.isInternalPath)('#baz', mockCatalogConfig)).toBe(true);
});

test('External path', function () {
  expect((0, _path.isInternalPath)('/whoa', mockCatalogConfig)).toBe(false);
});

// Base path

var mockCatalogConfigWithBasePath = {
  basePath: '/lalala',
  useBrowserHistory: true,
  pagePaths: new Set(['/lalala', '/lalala/foo/bar']),
  page: {
    path: '/lalala/foo/bar'
  }
};

test('Parse path with basePath set', function () {
  expect((0, _path.parsePath)('/foo/bar', mockCatalogConfigWithBasePath)).toEqual({ pathname: '/lalala/foo/bar', hash: '' });
});

test('Parse path with basePath set and basePath', function () {
  expect((0, _path.parsePath)('/lalala/foo/bar', mockCatalogConfigWithBasePath)).toEqual({ pathname: '/lalala/foo/bar', hash: '' });
});

test('Parse path with basePath set and trailing slash', function () {
  expect((0, _path.parsePath)('/foo/bar/', mockCatalogConfigWithBasePath)).toEqual({ pathname: '/lalala/foo/bar', hash: '' });
});

test('Parse path with basePath set and no leading slash', function () {
  expect((0, _path.parsePath)('foo/bar', mockCatalogConfigWithBasePath)).toEqual({ pathname: '/lalala/foo/bar', hash: '' });
});

test('Parse path with basePath set and hash', function () {
  expect((0, _path.parsePath)('/foo/bar#baz', mockCatalogConfigWithBasePath)).toEqual({ pathname: '/lalala/foo/bar', hash: '#baz' });
});

test('Parse path with basePath set and only hash (pathname is current page)', function () {
  expect((0, _path.parsePath)('#baz', mockCatalogConfigWithBasePath)).toEqual({ pathname: '/lalala/foo/bar', hash: '#baz' });
});

test('Leave index path alone with basePath set', function () {
  expect((0, _path.parsePath)('/lalala', mockCatalogConfigWithBasePath)).toEqual({ pathname: '/lalala', hash: '' });
});

// Internal paths

test('Internal path basePath set', function () {
  expect((0, _path.isInternalPath)('/foo/bar', mockCatalogConfigWithBasePath)).toBe(true);
});

test('Internal path with basePath set and trailing slash', function () {
  expect((0, _path.isInternalPath)('/foo/bar/', mockCatalogConfigWithBasePath)).toBe(true);
});

test('Internal path with basePath set and hash', function () {
  expect((0, _path.isInternalPath)('/foo/bar#baz', mockCatalogConfigWithBasePath)).toBe(true);
});

test('Internal path with basePath set and trailing slash and hash', function () {
  expect((0, _path.isInternalPath)('/foo/bar/#baz', mockCatalogConfigWithBasePath)).toBe(true);
});

test('Internal path with basePath set and only hash', function () {
  expect((0, _path.isInternalPath)('#baz', mockCatalogConfigWithBasePath)).toBe(true);
});

test('External path with basePath set', function () {
  expect((0, _path.isInternalPath)('/whoa', mockCatalogConfigWithBasePath)).toBe(false);
});

test('Internal path basePath set and basePath', function () {
  expect((0, _path.isInternalPath)('/lalala/foo/bar', mockCatalogConfigWithBasePath)).toBe(true);
});